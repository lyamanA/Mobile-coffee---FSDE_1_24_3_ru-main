  

Сегодня мы познакомимся с базовыми встроенными компонентами React Native, научимся их использовать и стилизовать, разберёмся с концепциями JSX и props, а также рассмотрим управление состоянием с помощью хуков useState и useEffect. В заключении теории мы введём основы навигации в приложении с помощью Expo Router. На практической части урока мы совместно создадим простое приложение с несколькими экранами (Главная, Профиль, Рецепт), чтобы закрепить полученные знания.

  

## **Обзор встроенных компонентов React Native**

  

React Native предоставляет ряд встроенных компонентов (Native Components), которые являются аналогами привычных HTML-тегов, но отображаются нативно на платформах iOS и Android. Ниже мы рассмотрим ключевые компоненты и их назначение:

  

### **View**

  

View – это базовый контейнер для layout (разметки) в React Native. Он аналогичен тегу <div> в веб-разработке. View используется для группировки и размещения других компонентов на экране, создания блоков интерфейса. Вы можете представлять его как “контейнер”, который помогает структурировать ваш UI.

  

Пример использования View:

```
import { View, Text, StyleSheet } from 'react-native';

export default function ExampleView() {
  return (
    <View style={styles.container}>
      <Text>Привет, мир!</Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    padding: 16,
    backgroundColor: '#EFEFEF'
  }
});
```

В этом примере мы оборачиваем текст “Привет, мир!” в компонент View с некоторыми стилями. View может содержать в себе любые другие элементы (даже другие View) и помогает организовать структуру интерфейса.

	  

**View** 
  

Text – компонент для отображения текста. В React Native **весь текст должен быть обёрнут в <Text>**, иначе приложение вызовет ошибку. Это отличие от веба, где текст можно писать непосредственно внутри блоков <div> или <span>. Text, по сути, заменяет такие теги как <p> или <span> и предназначен для вывода строк текста на экране.

  

Особенности компонента Text:

- Поддерживает стилизацию шрифта, размера, цвета и т.д. через стиль.
    
- Может включать в себя другие <Text> в качестве дочерних компонентов для раздельного форматирования частей строки.
    
- Имеет полезные props, например numberOfLines (ограничение количества отображаемых строк) или ellipsizeMode (режим сокращения текста).
    

  

Пример использования Text:

```
<View>
  <Text style={{ fontSize: 18, fontWeight: 'bold' }}>Заголовок</Text>
  <Text>Обычный текст абзаца, который просто отображается на экране.</Text>
</View>
```

Здесь первый элемент Text отображается как заголовок (большим жирным шрифтом), а второй – как обычный текст. Помните, что если вы хотите изменить стиль текста, это делается через prop style у компонента Text, а не с помощью обычного CSS (о стилях подробнее далее).

  

> **Важно:** Если вы попробуете вывести строку текста без оборачивания в <Text>, React Native выбросит ошибку: _“Text strings must be rendered within a  component”_.

  

### **Image**

  

Image – компонент для отображения изображений. Он похож на тег <img> в HTML, но имеет свой собственный набор свойств. Для отображения изображения необходимо указать источник (prop source). Источником может быть локальный файл (через require) или удалённый URL.

  

Особенности компонента Image:

- Требует указания размеров. В отличие от веб-страниц, где изображения могут автоматически подстраиваться, в RN нужно либо задать стили width/height, либо использовать стилевые решения (например, resizeMode).
    
- Prop source принимает объект вида { uri: 'https://...' } для внешних изображений или результат require('path/to/image.png') для локальных.
    
- Имеет prop resizeMode для управления тем, как изображение масштабируется (например, cover, contain, stretch и т.д.).
    

  

Пример использования Image с локальным и сетевым ресурсом:

```
<View>
  {/* Локальное изображение (должно находиться в проекте, например в папке assets) */}
  <Image source={require('../assets/logo.png')} style={{ width: 100, height: 100 }} />

  {/* Изображение по URL */}
  <Image 
    source={{ uri: 'https://picsum.photos/200/300' }} 
    style={{ width: 200, height: 300 }} 
  />
</View>
```

В первом случае мы отображаем локальный файл logo.png размером 100x100 пикселей. Во втором – загружаем изображение с указанного URL (случайное изображение 200x300) и задаём ему соответствующие размеры. Без указания style с размерами изображение может не отображаться.

  

### **ScrollView**

  

ScrollView – прокручиваемый (скроллируемый) контейнер. Если содержимое, размещённое внутри ScrollView, не помещается на экран, пользователь сможет прокручивать его (вертикально или горизонтально). ScrollView подходит для относительно небольших объёмов прокручиваемого контента.

  

Особенности ScrollView:

- По умолчанию обеспечивает вертикальную прокрутку. Для горизонтальной прокрутки нужно добавить prop horizontal={true}.
    
- Рендерит _все_ дочерние элементы сразу, поэтому неэффективен для очень длинных списков (для больших списков лучше использовать FlatList, о котором далее).
    
- Имеет различные props для управления поведением прокрутки (например, refreshControl для добавления pull-to-refresh, onScroll для обработки события прокрутки и др.).
    

  

Пример использования:

```
<ScrollView style={{ maxHeight: 200, backgroundColor: '#ddd' }}>
  <Text>Элемент 1</Text>
  <Text>Элемент 2</Text>
  {/* ... множество других элементов ... */}
  <Text>Элемент 20</Text>
</ScrollView>
```

В примере выше создаётся область с максимальной высотой 200, внутри которой 20 текстовых элементов. Если их общая высота превышает 200, можно будет прокручивать содержимое. ScrollView отобразит все эти элементы сразу.

  

### **TextInput**

  

TextInput – компонент для ввода текста пользователем (текстовое поле). Это аналог <input type="text"> или <textarea> в вебе. TextInput позволяет пользователю вводить текст с клавиатуры и предоставляет разработчику возможность читать и обрабатывать этот ввод.

  

Ключевые моменты:

- Может работать в **контролируемом** режиме (controlled) – когда текстовое поле имеет значение из состояния и при каждом изменении вызывается обработчик, обновляющий состояние.
    
- Основные props: value (текущее значение), onChangeText (функция-обработчик при изменении текста), placeholder (текст-заглушка, показываемый когда ничего не введено), secureTextEntry (для паролей, скрывает вводимые символы), keyboardType (тип клавиатуры, например numeric для ввода цифр) и др.
    
- По умолчанию TextInput — однострочный. Для многострочного ввода используется prop multiline={true}.
    

  

Пример контролируемого TextInput:

```
import { useState } from 'react';
import { TextInput, Text, View } from 'react-native';

export default function NameInputExample() {
  const [name, setName] = useState('');

  return (
    <View>
      <Text>Введите ваше имя:</Text>
      <TextInput
        value={name}
        onChangeText={newText => setName(newText)}
        placeholder="Ваше имя"
        style={{ borderColor: '#000', borderWidth: 1, padding: 8 }}
      />
      <Text>Привет, {name}!</Text>
    </View>
  );
}
```

В этом примере состояние name хранит текущее значение поля. По мере ввода текста в TextInput, вызывается setName и обновляет состояние, благодаря чему ниже в тексте сразу отображается приветствие с введённым именем. Обратите внимание: мы стилизовали TextInput рамкой (borderColor и borderWidth) для наглядности.

  

### **Pressable**

  

Pressable – это компонент-обёртка, который делает свой дочерний элемент “нажимабельным” (кликабельным/тачабельным). Он пришёл на смену устаревшим TouchableOpacity, TouchableHighlight и др., объединив их функциональность. Любой View или Text внутри Pressable станет интерактивным, реагируя на нажатия.

  

Ключевые моменты:

- Prop onPress – функция, которая вызывается при нажатии (когда пользователь отпустил палец/клик после нажатия).
    
- Дополнительные props: onPressIn, onPressOut, onLongPress для различных вариаций взаимодействий.
    
- Можно менять стиль Pressable или его дочерних компонентов в зависимости от состояния нажатия с помощью функции-пропа style={({ pressed }) => {...}} – это позволяет, например, делать эффект нажатия (изменять прозрачность, фон).
    

  

Пример кнопки на основе Pressable:

```
<Pressable 
  onPress={() => console.log('Button pressed!')} 
  style={({ pressed }) => [
    { padding: 10, backgroundColor: '#2196F3' },
    pressed && { opacity: 0.5 }
  ]}
>
  <Text style={{ color: '#fff' }}>Нажми меня</Text>
</Pressable>
```

Этот компонент отобразится как синяя кнопка с текстом. При нажатии прозрачность уменьшается до 0.5 (эффект нажатия), а в консоль выводится сообщение. Вы можете заменить console.log на любое действие, например, вызов навигации или изменение состояния.

  

### **FlatList**

  

FlatList – компонент для отображения прокручиваемого списка однотипных элементов. В отличие от ScrollView, FlatList не рендерит сразу все элементы, а делает это по мере прокрутки (ленивая загрузка), что повышает производительность на больших списках.

  

Основные особенности FlatList:

- Требует prop data – массив данных (элементы списка), и prop renderItem – функцию, которая описывает, как рендерить каждый элемент из data.
    
- Каждый элемент списка должен иметь уникальный ключ. Обычно FlatList ищет key в каждом элементе данных (например, item.key), или вы можете указать свойство keyExtractor – функцию для получения ключа из элемента.
    
- FlatList поддерживает заголовки списка, подвал, разделители между элементами и т.д. через соответствующие props (ListHeaderComponent, ItemSeparatorComponent и др.).
    

  

Пример использования FlatList:

```
const data = [
  { id: '1', title: 'Элемент 1' },
  { id: '2', title: 'Элемент 2' },
  { id: '3', title: 'Элемент 3' }
];

<FlatList
  data={data}
  renderItem={({ item }) => (
    <Text style={{ fontSize: 16 }}>✅ {item.title}</Text>
  )}
  keyExtractor={item => item.id}
/>
```

Здесь FlatList получает массив объектов с полями id и title. Для каждого элемента он отрисует компонент Text, отображающий эмоджи галочки и заголовок. Мы указали keyExtractor просто возвращающим item.id – таким образом FlatList использует id каждого элемента как уникальный ключ.

  

> **Замечание:** FlatList рендерит элементы лениво, поэтому он предпочтителен для списков, где может быть много элементов. Если элементов немного (несколько десятков максимум) и производительность не критична, можно использовать и ScrollView с ручным .map по массиву. Однако знание FlatList необходимо для создания оптимизированных списков в React Native.

  

## **Отличия компонентов React Native от веб-компонентов**

  

При переходе от веб-разработки к React Native важно понимать, что привычные веб-компоненты (DOM-теги) недоступны. Вместо них React Native предоставляет аналогичные по смыслу, но реализованные по-другому компоненты:

- **Отсутствие DOM:** В RN нет DOM-дерева и тегов вроде <div>, <span>, <img>, <button> и т.д. RN-компоненты (View, Text, Image, ScrollView и прочие) под капотом напрямую отображаются через нативные элементы платформы (UIView для iOS, View для Android и пр.). Это означает, что вы не работаете с document или window – интерфейс строится через JavaScript-bridge к нативным элементам.
    
- **Аналоги HTML-тегов:** Как мы рассмотрели, View играет роль контейнера (аналог <div>), Text – для текста (аналог <p> или <span>), Image – для изображений (<img>), TextInput – для полей ввода (<input>/<textarea>), Pressable – для интерактивных областей (аналог кнопок/ссылок).
    
- **Стилизация:** Вместо CSS и классов используются JavaScript-стили (объекты или StyleSheet). Нет поддержки каскадных селекторов, глобальных стилей по тегам и т.п. Стиль не наследуется так же, как в вебе (исключение – текст внутри <Text> может наследовать некоторые стили шрифта). Об этом подробнее в следующем разделе.
    
- **События и взаимодействие:** Обработчики событий отличаются по названию и возможностям. Например, вместо onClick используется onPress (для Pressable или Touchable компонентов), нет привычных событий фокуса/блюра через DOM (вместо них – свои props, как onFocus у TextInput и т.д.). Концепция всплытия событий (event bubbling) упрощена и ограничена по сравнению с DOM.
    
- **Отсутствие некоторых элементов:** Некоторые элементы, присутствующие в HTML, в RN отсутствуют или реализованы иначе. Например, нет прямого аналога <select> (вместо него можно использовать picker или собственные решения), <ul>/<li> для списков (списки делаются через обычные View/Text или FlatList), <table> (для табличных данных можно использовать ScrollView или сторонние библиотеки), <form> (формы собираются вручную, нет автоматической отправки).
    
- **Разный подход к навигации:** В вебе страницы переходят по URL, в RN нет смены страниц в браузере. Навигация реализуется библиотеками (такими как React Navigation или Expo Router) и имитирует переходы экранов внутри приложения. Expo Router, в частности, привносит знакомую концепцию URL и файловой структуры для определения экранов, но это работает поверх нативной навигации, а не через реальный переход браузера.
    

  

Важно перестроить своё мышление под эти отличия. Многие веб-концепции (например, DOM-дерево, CSS-каскад, семантические теги) не применимы в мобильном приложении на RN. Вместо этого нужно использовать предоставленные RN-компоненты и API для достижения тех же целей.

  

## **Стилизация в React Native (StyleSheet, inline-стили, Platform.OS)**

  

Стилизация интерфейса в React Native осуществляется с помощью JavaScript-объектов, а не отдельных CSS-файлов. Есть два основных подхода:

1. **Inline-стили**: непосредственно передать объект стилей в prop style компонента.
    
2. **StyleSheet**: создать объект стилей с помощью StyleSheet.create() и затем использовать его свойства.
    

  

Оба подхода работают идентично с точки зрения результата, но использование StyleSheet помогает организовать код и может слегка оптимизировать работу (RN может при сборке сопоставить стили с ID для более эффективной отрисовки).

  

**Принципы стилей в RN:**

- Свойства стиля похожи на CSS, но пишутся в _camelCase_. Например: backgroundColor вместо background-color, marginTop вместо margin-top.
    
- Единицы измерения: числа в стилях RN интерпретируются как **пиксели** (точнее, density-independent pixels). Вам не нужно писать 'px'. Строки могут использоваться для процентов (напр. "50%"), но большинство случаев – числа.
    
- Некоторые CSS-свойства недоступны, однако React Native поддерживает Flexbox для макета, позиционирование (position, top, left и т.д.), и большинство свойств для размеров, отступов, цвета фона, границ, теней и т.п.
    
- Стили не наследуются, за исключением вложенного текста: стили родительского Text применяются к дочернему Text по умолчанию. В остальных случаях каждый компонент полностью изолирован по стилю.
    

  

**Пример использования StyleSheet:**

```
import { StyleSheet, View, Text } from 'react-native';

export default function StyledBox() {
  return (
    <View style={styles.container}>
      <Text style={styles.title}>Заголовок</Text>
      <Text style={styles.paragraph}>Абзац текста, описывающий что-то важное.</Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    padding: 16,
    backgroundColor: '#F5F5F5',
    // Пример использования flexbox:
    flex: 1,            // контейнер заполняет все доступное пространство
    flexDirection: 'column', // (это значение по умолчанию) элементы располагаются по вертикали
    justifyContent: 'center', // выравнивание по вертикали (центровка)
    alignItems: 'center'    // выравнивание по горизонтали (центровка)
  },
  title: {
    fontSize: 20,
    fontWeight: '600',
    marginBottom: 8
  },
  paragraph: {
    fontSize: 16,
    color: '#333'
  }
});
```

Здесь мы создали объект styles с тремя стилевыми “классами”: container, title, paragraph. Затем применили их к соответствующим View и Text. Обратите внимание на использование Flexbox-свойств: мы сделали контейнер полноэкранным и центрировали содержимое по вертикали и горизонтали.

  

**Inline-стили:**

Любой стиль можно передать напрямую через объект. Например:

```
<View style={{ padding: 16, backgroundColor: 'red' }}>
  <Text style={{ color: 'white' }}>Пример</Text>
</View>
```

Это эквивалентно использованию StyleSheet, но при росте кода inline-стили могут стать громоздкими. Их удобно использовать для простых случаев или динамических стилей.

  

**Комбинирование стилей:**

Prop style может принимать массив, что позволяет комбинировать несколько объектов стилей. Например:

```
<View style={[styles.container, { backgroundColor: 'yellow' }]}>
  {/* ... */}
</View>
```

Здесь базовый стиль container будет объединён с дополнительным объектом (фон желтый). Правила правее в массиве перекрывают левые.

  

**Platform.OS и условные стили:**

Иногда оформление на iOS и Android требуется разное. React Native предоставляет модуль Platform с помощью которого можно определить, на какой ОС запущено приложение. Platform.OS вернёт строку "ios" или "android" (а также "web", если приложение запущено в браузере).

  

Вы можете применять Platform.OS для условного задания стилей или логики:

```
import { Platform, StyleSheet } from 'react-native';

const styles = StyleSheet.create({
  button: {
    padding: 10,
    backgroundColor: Platform.OS === 'ios' ? 'blue' : 'green',
    ...Platform.select({
      ios: { borderRadius: 8 },      // скругленные углы на iOS
      android: { borderRadius: 0 }   // квадратные углы на Android
    })
  }
});
```

В этом примере цвет кнопки будет синим на iOS и зелёным на Android. Также с помощью Platform.select мы задаём разные значения borderRadius. Такой код применит соответствующий блок стилей в зависимости от платформы.

  

Кроме Platform.OS, React Native позволяет создавать файлы с суффиксами для разных платформ (например, Component.ios.js и Component.android.js), однако на начальном этапе достаточно условных выражений. Используйте платформенные отличия только там, где это необходимо для соответствия гайдам платформы или требованиям дизайна.

  

## **JSX и props в React Native**

  

React Native использует JSX – расширение синтаксиса JavaScript, при котором вы пишете разметку прямо внутри кода. JSX выглядит как HTML/XML, но под капотом превращается в вызовы React.createElement. В предыдущем уроке вы уже сталкивались с JSX, когда создавали первый компонент.

  

**Особенности JSX:**

- **Единый возвращаемый элемент:** Компонент должен возвращать один корневой элемент. Поэтому, если нужно вернуть несколько соседних элементов, оборачивайте их в <View> или используйте пустой контейнер <>...</> (React Fragment).
    
- **Вставка JavaScript:** Внутри JSX вы можете использовать выражения JavaScript, обернув их в фигурные скобки { }. Например, <Text>{1 + 2}</Text> отобразит “3”, а <Text>{name}</Text> отобразит значение переменной name.
    
- **Атрибуты в JSX:** Они же **props** – свойства компонентов. Передаются аналогично HTML-атрибутам, но имена соответствуют свойствам React Native-компонентов (например, source для Image, onPress для Pressable и т.д.).
    
- **Строгость синтаксиса:** JSX чувствителен к регистрам (большие/маленькие буквы). Все встроенные компоненты RN должны быть с большой буквы (View, Text…), иначе JSX думает, что это HTML-тег. Также нужно закрывать все теги, даже одиночные (например, <Image ... />).
    

  

Пример JSX с встраиванием переменных:

```
const username = 'Вася';
return (
  <View>
    <Text>Привет, {username}!</Text>
    <Text>Сегодня {new Date().toLocaleDateString()}.</Text>
  </View>
);
```

Здесь во второй строке JSX вставляется текущая дата, которая будет вычислена и отрендерена внутри текста.

  

Теперь поговорим о **props** (properties) – свойствах компонентов. Props позволяют настраивать компоненты или передавать данные в дочерние компоненты. По сути, пропсы – это параметры, с которыми компонент вызывается.

  

**Работа с props:**

- Встроенные компоненты React Native имеют предопределённые props (например, у TextInput есть prop placeholder, value, keyboardType и др., у Image – source, resizeMode и т.д.).
    
- Пользовательские компоненты (те, что вы создаёте сами) могут принимать произвольные props. В функциональных компонентах они доступны в виде параметра функции.
    

  

Пример собственного компонента с пропсами:

```
// Определяем компонент, который отображает приветствие
function Greeting(props) {
  return <Text>Привет, {props.name}!</Text>;
}

// Используем компонент Greeting и передаём пропс name
export default function WelcomeScreen() {
  return (
    <View>
      <Greeting name="Мир" />
      <Greeting name="Алиса" />
    </View>
  );
}
```

В этом примере компонент Greeting ожидает проп name и использует его в JSX. Когда мы рендерим <Greeting name="Мир" />, внутри компонента Greeting значение props.name будет равно “Мир”. Таким образом выводится “Привет, Мир!”. При повторном использовании с другим именем отобразится другое приветствие.

  

Заметьте:

- Мы обращаемся к пропсам объекта props. В функциональных компонентах также можно использовать деструктуризацию: function Greeting({ name }) { return <Text>Привет, {name}!</Text>; }.
    
- Если пропс не передан, props.name будет undefined (ничего не покажет). Можно задавать значения по умолчанию либо обрабатывать отсутствие пропса внутри компонента.
    

  

**Props встроенных компонентов:** Вы уже использовали много props, возможно не задумываясь об этом. Например, в <Text style={styles.title}> вы передали проп style. В <Pressable onPress={...}> – проп onPress. Даже содержимое между открывающим и закрывающим тегом <Text>...</Text> считается пропсом children. Props – основной механизм настройки компонентов.

  

**Неизменяемость props:** Важно помнить, что компонент **не должен изменять свои пропсы**. Props считаются входными данными, которые “текут” сверху вниз. Если компоненту нужно изменить какие-то данные в ходе работы – для этого используется состояние (state), о котором далее. Пропсы же получают значение от родителя и используются только для отображения или передачи дальше дочерним элементам.

  

## **Работа с состоянием (Hooks: useState и useEffect)**

  

В React (и React Native) **состояние** используется для хранения данных, которые меняются со временем и влияют на отображение компонента. Каждый раз при изменении состояния React заново рендерит компонент, показывая актуальные данные. В функциональных компонентах состояние управляется с помощью **хуков** – специальных функций React. Два самых важных хука для работы с состоянием и эффектами – useState и useEffect.

  

### **Хук useState**

  

useState позволяет добавить состояние в функциональный компонент. Он принимает начальное значение и возвращает массив из двух элементов: текущего значения состояния и функции для его изменения.

  

Пример: счётчик, увеличивающийся при нажатии кнопки:

```
import { useState } from 'react';
import { View, Text, Pressable } from 'react-native';

export default function Counter() {
  const [count, setCount] = useState(0); // инициализируем count = 0

  return (
    <View style={{ alignItems: 'center' }}>
      <Text style={{ fontSize: 18 }}>Счёт: {count}</Text>
      <Pressable 
        onPress={() => setCount(count + 1)} 
        style={{ padding: 10, backgroundColor: '#ddd', marginTop: 10 }}
      >
        <Text>Увеличить</Text>
      </Pressable>
    </View>
  );
}
```

Здесь мы объявили состояние count и функцию setCount для его обновления. Начальное значение равно 0. Каждый раз, когда пользователь нажимает на Pressable, вызывается setCount(count + 1), что увеличивает count. В результате React Native перерассчитывает JSX и обновляет текст в компоненте <Text>Счёт: {count}</Text> на новое значение.

  

Особенности useState:

- Можно вызывать хук useState несколько раз в одном компоненте (для разных независимых состояний).
    
- Функция обновления состояния (setCount) вызывает перерисовку компонента. Новый рендер увидит обновленное значение count.
    
- Обновление состояния происходит асинхронно и может быть группировано React-ом для оптимизации. Поэтому не стоит рассчитывать на немедленное обновление переменной после вызова setState (лучше использовать эффект или другие хуки, если нужно отреагировать на изменение).
    
- Если новое значение состояния рассчитывается на основе предыдущего, рекомендуется использовать функцию вместо прямого значения: setCount(prevCount => prevCount + 1). Это особенно актуально, когда обновления вызываются быстро или одновременно.
    

  

### **Хук useEffect**

  

useEffect позволяет выполнять побочные эффекты в компонентах: вызовы API, подписки на события, таймеры, логирование и т.д. Этот хук принимает функцию-эффект и массив зависимостей. Он автоматически вызывается после отрисовки компонента (после его render).

  

Синтаксис: useEffect(effectFunc, [deps])

- effectFunc – функция, выполняющая необходимый эффект. Опционально она может возвращать функцию очистки (cleanup).
    
- [deps] – массив зависимостей. Эффект будет запускаться снова только если изменится одна из зависимостей. Если передать пустой массив [], эффект выполнится лишь однажды после первого рендера (аналогично componentDidMount). Если не передавать второй аргумент вовсе, эффект будет выполняться после каждого обновления (каждого рендера компонента).
    

  

Пример: логирование изменения счётчика из предыдущего примера:

```
useEffect(() => {
  console.log('Изменилось значение count:', count);
}, [count]);
```

Этот эффект будет срабатывать каждый раз, когда меняется count. Он будет выводить новое значение счётчика в консоль (например, в логи эмулятора). Если count не менялся при перерисовке, эффект не запускается.

  

Другой пример: имитация загрузки данных при монтировании компонента:

```
useEffect(() => {
  // Этот код выполнится один раз при первом появлении компонента
  fetchDataFromServer();

  // Не забудьте указать зависимости!
}, []); // пустой массив зависимостей => эффект только при монтировании
```

Здесь fetchDataFromServer() – это условная функция, которая получит данные (например, список рецептов) с сервера. Пустой массив зависимостей гарантирует, что мы не будем выполнять загрузку при каждом рендере, а только один раз.

  

**Очистка эффектов:** Если effectFunc возвращает функцию, она будет вызвана при размонтировании компонента или перед следующим выполнением эффекта (если зависимости изменились). Это полезно для очистки ресурсов: отписаться от подписок, очистить таймеры и т.д. Например:

```
useEffect(() => {
  const intervalId = setInterval(() => {
    console.log('Таймер тик');
  }, 1000);

  // Функция очистки
  return () => {
    clearInterval(intervalId);
    console.log('Таймер остановлен');
  };
}, []);
```

В этом примере каждую секунду будет писаться “Таймер тик”, а когда компонент уйдёт со страницы (или эффект перезапустится), интервал очистится и выведется сообщение об остановке.

  

**Важные моменты при работе с эффектами:**

- **Не вызывайте эффекты внутри условий или циклов** – хуки должны вызываться на верхнем уровне компонента, иначе порядок вызовов может нарушиться.
    
- Следите за зависимостями: если вы используете внутри эффекта переменные или функции из внешней области, добавьте их в массив зависимостей, иначе React может показать предупреждение. Исключение – функции из сторонних библиотек или константы, которые гарантированно не меняются.
    
- Не обновляйте состояние безусловно внутри эффекта – это может привести к бесконечному циклу (эффект -> setState -> ререндер -> эффект -> …). Если нужно обновить состояние в эффекте, убедитесь, что массив зависимостей настроен правильно (например, эффект запускается один раз или реагирует на конкретные изменения).
    

  

Используя useState и useEffect совместно, вы можете управлять данными и реагировать на их изменения. Это основа интерактивности приложения. В следующей части мы рассмотрим, как управлять переходами между экранами, что потребует сочетания всех изученных концепций (компоненты, props, состояние и эффекты).

  

## **Введение в навигацию с Expo Router**

  

Мобильные приложения обычно состоят из нескольких экранов, между которыми нужно переходить. В React Native одним из самых популярных способов навигации является библиотека **React Navigation**. Expo Router построен поверх React Navigation, но предоставляет более простой и декларативный подход к управлению экранами, используя файловую структуру (похожую на подход Next.js в веб-разработке).

  

**Expo Router** позволяет определять экраны приложения через файлы и папки внутри директории app. Каждый файл с компонентом становится страницей (экраном), а путь к файлу определяет маршрут (URL). Expo Router автоматически настроит навигацию на основе этих файлов.

  

Рассмотрим основные понятия Expo Router:

  

### **Структура файлов навигации**

  

Предположим, у нас есть структура папки app в проекте:

```
app/
 ├─ _layout.tsx
 ├─ index.tsx
 ├─ profile.tsx
 └─ recipe/
     └─ [id].tsx
```

- app/_layout.tsx – специальный файл _layout_. Он определяет общую оболочку для экранов и тип навигации (например, стек навигации). Layout заменяет собой традиционный файл App.js/App.tsx. Обычно внутри _layout.tsx используется навигационный контейнер. Простейший пример layout-файла:
    

```
import { Stack } from 'expo-router';
export default function RootLayout() {
  return <Stack />;
}
```

- Этот код говорит Expo Router использовать Stack Navigator (по умолчанию, с заголовками экранов и возможностью переходов назад) для всех экранов внутри папки.
    
- app/index.tsx – экран “Главная” (маршрут /). Файл с именем index соответствует корневому пути или пути папки, в которой находится. В данном случае это основной экран приложения.
    
- app/profile.tsx – экран “Профиль” (маршрут /profile).
    
- app/recipe/[id].tsx – экран “Рецепт” с динамическим параметром id (маршрут вида /recipe/42 или любой другой ID).
    

  

Expo Router считывает эту структуру и автоматически регистрирует маршруты:

- Заходя в приложение, откроется первый найденный index (здесь app/index.tsx).
    
- Переход на /profile отобразит компонент из profile.tsx.
    
- Переход на маршрут /recipe/abc отобразит компонент из [id].tsx и передаст строку "abc" в качестве параметра id.
    

  

### **Статические и динамические маршруты**

  

**Статические маршруты** определяются обычными именами файлов. Например, profile.tsx – статический маршрут. URL маршрута совпадает с именем файла (без расширения). Несколько примеров:

- app/about.tsx -> маршрут /about
    
- app/contact.tsx -> маршрут /contact
    

  

**Динамические маршруты** позволяют обрабатывать URL с переменными частями. Они обозначаются квадратными скобками. Наш пример app/recipe/[id].tsx означает, что этот экран отобразится для любого маршрута вида /recipe/что-угодно (например, /recipe/1, /recipe/42, /recipe/pizza). Часть URL вместо [id] будет передана в компонент как параметр.

  

Как получить значение параметра внутри компонента? Expo Router предоставляет хук useLocalSearchParams (или useSearchParams) для доступа к параметрам текущего маршрута:

```
import { useLocalSearchParams } from 'expo-router';

export default function RecipeScreen() {
  const { id } = useLocalSearchParams();
  
  return <Text>Это экран рецепта с ID: {id}</Text>;
}
```

Если пользователь перешел по пути /recipe/42, то в приведённом примере id будет строкой "42". Внутри компонента мы можем использовать этот параметр, например, чтобы загрузить данные конкретного рецепта или показать соответствующую информацию. (Заметьте, id приходит в виде строки; при необходимости, если это число, вы можете конвертировать его с помощью Number(id)).

  

Вы можете иметь несколько динамических сегментов. Например, файл app/[username]/settings.tsx будет соответствовать пути /alice/settings и внутри компонента можно получить username: "alice" через useLocalSearchParams.

  

### **Компонент Link для навигации**

  

Expo Router предлагает компонент <Link> для навигации, аналогично ссылкам в вебе. Используя Link, вы можете перейти на другой экран, указав prop href (путь).

  

Пример:

```
import { Link } from 'expo-router';

<View>
  <Text>Главная страница</Text>
  <Link href="/profile">
    <Text style={{ color: 'blue' }}>Перейти в Профиль</Text>
  </Link>
</View>
```

При нажатии на этот текст произойдет переход на экран /profile. Обратите внимание: по умолчанию Link оборачивает детей в <Text> и поэтому сам дочерний элемент здесь – Text с синим цветом, смотрящийся как гиперссылка. Для нестандартного оформления можно воспользоваться трюком: prop asChild у Link.

  

Пример использования asChild:

```
<Link href="/profile" asChild>
  <Pressable style={{ padding: 10, backgroundColor: 'lightgray' }}>
    <Text>Открыть Профиль</Text>
  </Pressable>
</Link>
```

Здесь <Link> не будет сам ничего рисовать, а передаст все пропсы внутрь <Pressable> (первого ребенка). В результате кликабельной становится область Pressable с указанным стилем. Это удобно, когда нужно стилизовать кнопку перехода не как простой текст.

  

### **Хук useRouter для навигации из кода**

  

Помимо компонента Link, иногда необходимо выполнить навигацию программно, в результате какого-то события или логики (например, после успешного логина перейти на экран профиля). Для этого используется хук useRouter.

  

const router = useRouter();

  

Хук возвращает объект router с методами навигации:

- router.push(<путь>) – перейти на новый экран, добавив его в стек навигации.
    
- router.replace(<путь>) – перейти на экран, **заменив** текущий (текущий экран убирается из стека). Полезно, например, для экранов авторизации, чтобы не возвращаться назад к экрану входа после входа.
    
- router.back() – вернуться на предыдущий экран (аналог нажатия “назад”).
    
- Также доступны: router.canGoBack() (есть ли куда вернуться), router.push({ pathname, params }) (альтернативный синтаксис перехода с указанием объекта пути и параметров) и другие.
    

  

Пример использования useRouter:

```
import { useRouter } from 'expo-router';

function HomeScreen() {
  const router = useRouter();

  const openRandomRecipe = () => {
    // Допустим, хотим открыть рецепт с id=42
    router.push('/recipe/42');
  };

  return (
    <View>
      {/* ... какой-то интерфейс ... */}
      <Pressable onPress={openRandomRecipe}>
        <Text>Открыть случайный рецепт</Text>
      </Pressable>
    </View>
  );
}
```

Здесь при нажатии на Pressable вызывается router.push('/recipe/42'), и приложение перейдёт на экран рецепта с идентификатором 42. В реальных приложениях вы бы подставили динамически выбранный ID (например, случайный или первый из списка и т.п.).

  

**Итог по Expo Router:** Этот подход позволяет описывать навигацию декларативно. Добавляя новый файл, вы автоматически добавляете новый экран и маршрут. С помощью Link и useRouter можно организовывать переходы между экранами. Expo Router берёт на себя детали настройки навигации, такие как создание Navigation Container, StackNavigator и прочее, предоставляя нам простой интерфейс для объявлений маршрутов.

  

Далее на практике мы применим Expo Router, создав небольшое приложение с двумя-тремя экранами.

  

## **Практика: Создаем приложение “Список рецептов”**

  

Теперь, когда мы разобрали основные концепции, перейдём к практической работе. Мы создадим простое приложение с тремя экранами:

- **Главная (Home)** – будет отображать список неких рецептов.
    
- **Профиль (Profile)** – экран с информацией профиля пользователя (для примера – просто имя, вводимое через TextInput).
    
- **Рецепт (Recipe)** – экран с деталями рецепта, который открывается по нажатию на пункт из списка (динамический маршрут с идентификатором).
    

  

Мы будем использовать Expo Router для навигации между экранами и задействуем компоненты: ScrollView, FlatList, Pressable, TextInput и т.д.

  

### **Шаг 1. Подготовка проекта с Expo Router**

  

Если вы начинаете с нуля, создайте новый проект с шаблоном Expo Router или добавьте Expo Router в существующий:

- **Новый проект**: выполните в консоли команду: npx create-expo-app -e with-router имя-проекта. Это создаст новое Expo-приложение с уже настроенным Expo Router.
    
- **Добавление в существующий проект**: установите библиотеку командой npx expo install expo-router (а также связанные зависимости, если попросит). Затем в package.json пропишите "main": "expo-router/entry" и создайте папку app в корне проекта. Перенесите или создайте внутри неё файлы экранов.
    

  

_(Примечание: Возможно, эти шаги уже были выполнены преподавателем заранее. Убедитесь, что у вас есть папка_ _app_ _и настроен entry point. По сути, наличие_ _app/_layout.tsx_ _и других экранов означает, что Expo Router активен.)_

  

### **Шаг 2. Создание файла layout (навигатора)**

  

Создадим файл app/_layout.tsx, отвечающий за конфигурацию навигации. Мы воспользуемся стек-навигацией (Stack), которая обеспечивает заголовки и переходы “назад”.

  

app/_layout.tsx:

```
import { Stack } from 'expo-router';

export default function RootLayout() {
  return (
    <Stack screenOptions={{ headerTitleAlign: 'center' }}>
      <Stack.Screen name="index" options={{ title: 'Главная' }} />
      <Stack.Screen name="profile" options={{ title: 'Профиль' }} />
      <Stack.Screen name="recipe/[id]" options={{ title: 'Рецепт' }} />
    </Stack>
  );
}
```

Здесь мы:

- Импортируем Stack из expo-router и возвращаем его в JSX. Это создаёт Stack Navigator.
    
- Внутри <Stack> указываем конкретные экраны через <Stack.Screen>. Prop name должен соответствовать имени файла (без расширения). Мы настроили заголовки (title) для каждого экрана на русский язык (по умолчанию заголовок генерируется из имени файла).
    
- Опция headerTitleAlign: 'center' выравнивает заголовок по центру (это эстетика, опционально).
    

  

Этот layout будет автоматически применён ко всем экранам в папке app. Теперь настроим сами экраны.

  

### **Шаг 3. Главный экран (Home)**

  

Создадим app/index.tsx. Это будет главный экран со списком рецептов и ссылками на другие экраны.

  

app/index.tsx:

```
import { useRouter, Link } from 'expo-router';
import { View, Text, FlatList, Pressable, StyleSheet } from 'react-native';

const recipes = [
  { id: '1', title: 'Пицца Маргарита' },
  { id: '2', title: 'Суши Филадельфия' },
  { id: '3', title: 'Борщ украинский' }
];

export default function HomeScreen() {
  const router = useRouter();

  return (
    <View style={styles.container}>
      <Text style={styles.header}>Список рецептов</Text>

      {/* Кнопка/ссылка на экран Профиля */}
      <Link href="/profile" asChild>
        <Pressable style={styles.profileButton}>
          <Text style={styles.profileButtonText}>Открыть профиль</Text>
        </Pressable>
      </Link>

      {/* Список рецептов */}
      <FlatList
        data={recipes}
        renderItem={({ item }) => (
          <Pressable 
            style={styles.recipeItem} 
            onPress={() => router.push(`/recipe/${item.id}`)}
          >
            <Text style={styles.recipeTitle}>{item.title}</Text>
          </Pressable>
        )}
        keyExtractor={(item) => item.id}
        style={styles.list}
      />
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 16
  },
  header: {
    fontSize: 24,
    fontWeight: 'bold',
    marginBottom: 12
  },
  profileButton: {
    marginBottom: 16,
    padding: 12,
    backgroundColor: '#2196F3',
    borderRadius: 4
  },
  profileButtonText: {
    color: '#fff',
    textAlign: 'center'
  },
  list: {
    flex: 1
  },
  recipeItem: {
    padding: 12,
    marginBottom: 8,
    backgroundColor: '#f2f2f2',
    borderRadius: 4
  },
  recipeTitle: {
    fontSize: 18
  }
});
```

Разберём ключевые моменты:

- Мы создали массив recipes с тремя объектами, каждый имеет id и title. В реальном приложении это могли бы быть данные, полученные с сервера, но для примера используем статичный список.
    
- Используем FlatList для отображения списка. Каждый элемент списка – название рецепта, обёрнутое в Pressable.
    
- При рендеринге каждого элемента (renderItem) мы создаём <Pressable> и обрабатываем нажатие: onPress={() => router.push(/recipe/${item.id})}. Таким образом, при нажатии на рецепт осуществляется переход на динамический маршрут /recipe/ID. Мы используем хук useRouter для доступа к функции router.push.
    
- Также наверху экрана добавили кнопку профиля: <Link href="/profile" asChild> оборачивает Pressable, создавая кнопку перехода на экран профиля.
    
- Стили определены в StyleSheet.create для упорядоченности.
    

  

Запустите приложение (например, npm run ios/npm run android или npx expo start и эмулируйте) и убедитесь, что:

- Отображается заголовок “Список рецептов”.
    
- Есть кнопка “Открыть профиль”.
    
- Список из трёх рецептов, каждый из которых нажимается (кликабелен).
    

  

Попробуйте нажать на названия рецептов – ничего не произойдёт напрямую, потому что мы ещё не создали экран рецепта. Кнопка “Открыть профиль” уже должна работать (экран профиля мы сейчас создадим).

  

### **Шаг 4. Экран профиля (Profile)**

  

Создадим app/profile.tsx. Здесь продемонстрируем ввод текста и использование состояния.

  

app/profile.tsx:

```
import { useState } from 'react';
import { View, Text, TextInput, StyleSheet } from 'react-native';

export default function ProfileScreen() {
  const [name, setName] = useState('');

  return (
    <View style={styles.container}>
      <Text style{styles.label}>Имя пользователя:</Text>
      <TextInput
        value={name}
        onChangeText={setName}
        placeholder="Введите имя"
        style={styles.input}
      />
      <Text style={styles.greeting}>
        Привет, {name || 'незнакомец'}!
      </Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 16,
    alignItems: 'center'
  },
  label: {
    fontSize: 18,
    marginBottom: 8
  },
  input: {
    width: '100%',
    padding: 8,
    fontSize: 16,
    borderColor: '#aaa',
    borderWidth: 1,
    borderRadius: 4,
    marginBottom: 16
  },
  greeting: {
    fontSize: 20,
    fontWeight: '500'
  }
});
```

Что здесь происходит:

- Мы используем useState для хранения имени пользователя (name). Изначально оно пустое.
    
- Отображаем метку “Имя пользователя:” и поле ввода <TextInput>. Значение TextInput привязано к состоянию name (через prop value), а при изменении текста вызывается setName (через onChangeText), так что name всегда содержит актуальный ввод.
    
- Ниже мы показываем приветствие: "Привет, {name || 'незнакомец'}!". Конструкция {name || 'незнакомец'} означает: если name не пустое, покажем его, иначе слово ‘незнакомец’. Таким образом, сразу после открытия экрана будет “Привет, незнакомец!”, а когда пользователь введёт своё имя, текст обновится, например, на “Привет, Вася!”.
    
- Стили оформления: контейнер центрирован, TextInput имеет рамку и скругление, greeting – увеличенный полужирный текст.
    

  

Теперь переход между экранами:

- Если открыть профиль через кнопку, появится этот экран с полем ввода.
    
- Вы можете ввести имя, и оно сразу отобразится ниже.
    
- Обратите внимание: благодаря Stack Navigator, в заголовке экрана уже будет кнопка “Назад” (или стрелка) для возврата на Главную.
    

  

### **Шаг 5. Экран рецепта (Recipe Detail)**

  

Создадим app/recipe/[id].tsx. Это динамический экран, показывающий детали рецепта на основе переданного ID.

  

app/recipe/[id].tsx:

```
import { useLocalSearchParams } from 'expo-router';
import { ScrollView, View, Text, StyleSheet } from 'react-native';

export default function RecipeDetailScreen() {
  const { id } = useLocalSearchParams();
  
  // Для примера создадим простой контент на основе id
  return (
    <ScrollView contentContainerStyle={styles.container}>
      <Text style={styles.title}>Рецепт #{id}</Text>
      <Text style={styles.content}>
        Это страница рецепта с идентификатором {id}. 
        Здесь могла бы быть подробная информация о блюде, ингредиенты, шаги приготовления и т.д.
        Для демонстрации мы ограничимся этим текстом. Прокрутите вниз, чтобы увидеть больше текста.
      </Text>
      <Text style={styles.content}>
        Lorem ipsum dolor sit amet, consectetur adipiscing elit. 
        Praesent suscipit urna at neque facilisis, vitae interdum quam fringilla. 
        Donec posuere, nibh nec luctus sagittis, urna purus vehicula nisl, in tincidunt purus dolor nec purus.
      </Text>
      <Text style={styles.content}>
        Curabitur euismod sem vel augue consectetur, a fermentum leo interdum. 
        Aenean nec hendrerit mauris. Nulla facilisi. 
        Mauris vehicula vulputate felis, at placerat elit imperdiet in.
      </Text>
    </ScrollView>
  );
}

const styles = StyleSheet.create({
  container: {
    padding: 16
  },
  title: {
    fontSize: 22,
    fontWeight: 'bold',
    marginBottom: 12
  },
  content: {
    fontSize: 16,
    marginBottom: 10,
    lineHeight: 22
  }
});
```

Разбор:

- С помощью useLocalSearchParams() мы получаем объект параметров. Мы ожидаем, что будет параметр id (так как файл называется [id].tsx). Деструктурируем его.
    
- Используем ScrollView с contentContainerStyle для стилизации внутреннего содержимого и возможности прокрутки. Мы вставили несколько <Text> абзацев, чтобы получился прокручиваемый текст (эмулируя длинное описание рецепта).
    
- Заголовок отображает “Рецепт #ID”.
    
- Три блока текста имитируют содержание рецепта (во втором и третьем блоке просто латинский текст для заполнения места).
    
- Если данных в ScrollView по высоте больше, чем экран, появится прокрутка (на практике это описание может быть очень длинным, потому ScrollView здесь уместен).
    

  

Теперь запустите приложение и протестируйте полный поток:

1. На главном экране нажмите на один из рецептов, например “Пицца Маргарита”.
    
2. Вы должны перейти на экран рецепта с заголовком “Рецепт #1” (если вы нажали на id 1). Видна страница с текстом, которую можно прокручивать.
    
3. В шапке экрана “Рецепт” есть стрелка назад – используйте её, чтобы вернуться на главную.
    
4. Попробуйте другой рецепт – откроется экран с соответствующим номером.
    
5. Перейдите в “Профиль” через кнопку – откроется экран профиля (также со стрелкой назад). Введите имя, убедитесь, что оно отображается. Вернитесь назад.
    

  

Отлично, мы собрали простое многоэкранное приложение! Хотя оно демонстрационное, в нём задействованы важные элементы:

- Навигация между экранами (Expo Router, статические и динамические маршруты).
    
- Отображение списков (FlatList) и переход по нажатию на элемент списка.
    
- Ввод данных пользователем (TextInput) и отражение этого ввода в интерфейсе через состояние.
    
- Прокрутка длинного контента (ScrollView).
    

  

### **Упражнения для закрепления**

  

Чтобы лучше закрепить материал, попробуйте выполнить следующие задания:

1. **Добавьте новый экран.** Например, создайте экран app/about.tsx с некоторой информацией “О приложении” (текст о том, что это демо-приложение). На главном экране добавьте ссылку/кнопку на этот новый экран. Убедитесь, что переход работает и у экрана есть свой заголовок.
    
2. **Измените внешний вид.** Попробуйте поменять стили некоторых компонентов:
    
    - Сделайте элементы списка рецептов (названия блюд) разными цветами или увеличьте шрифт.
        
    - Для платформы iOS сделайте фон экрана профиля другим цветом, используя Platform.OS.
        
    - Добавьте картинку на экран профиля или рецепт (например, логотип или изображение блюда, используя компонент Image).
        
    
3. **Практика с состоянием.** Добавьте на экран профиля счётчик, который увеличивается каждый раз, когда вы открываете этот экран (подсказка: использовать useEffect с пустым массивом зависимостей для увеличения значения в состоянии при монтировании экрана профиля).
    

  

Выполнение этих упражнений поможет вам лучше понять механизм работы компонентов и навигации в React Native.

  

## **Возможные ошибки и способы их решения**

  

При разработке на React Native у начинающих часто возникают следующие проблемы:

- **“Text strings must be rendered within a  component”:** Эта ошибка возникает, если вы пытаетесь отобразить строку текста вне компонента <Text>. Решение – всегда оборачивать текст в <Text>.
    
- **Отсутствие ключей в списках:** Если вы используете массив и метод .map (или FlatList без указания keyExtractor), React может выдавать предупреждение о ключах. Убедитесь, что каждый элемент списка имеет уникальный key (например, используйте идентификатор или индекс). В FlatList всегда задавайте keyExtractor или включайте поле key в объекты данных.
    
- **Ошибки импорта:** Если вы видите ошибку типа “Undefined is not an object” или что-то не отображается, проверьте, импортировали ли вы все необходимые компоненты и хуки. Например, useState нужно импортировать из ‘react’, компоненты – из ‘react-native’, Link и прочие – из ‘expo-router’.
    
- **Опечатки в именах файлов маршрутов:** Если вы назвали файл с экраном неправильно (например, Profile.tsx с большой буквы вместо profile.tsx), маршрут может не резолвиться. В Expo Router имена файлов чувствительны к регистру и должны совпадать с тем, что вы указываете в путях. Также убедитесь, что динамические сегменты оформлены верно (скобки).
    
- **Необновлённый state:** Если при вводе в TextInput текст не появляется где нужно – проверьте, что вы правильно привязали значение state и функцию изменения. Частая ошибка – использовать onChangeText={setName} без инициализации const [name, setName] = useState(''), или наоборот, обновлять переменную напрямую вместо вызова set-функции.
    
- **Бесконечный ререндер/цикл:** Это может произойти, если вы вызываете функцию обновления состояния каждый раз при рендере без условий (например, внутри компонента или эффекта без зависимостей). Убедитесь, что useEffect настроен правильно – если в нём происходит setState, он не должен запускаться бесконечно (проверьте массив зависимостей).
    
- **Проблемы с навигацией:** Если при нажатии на Link или router.push ничего не происходит или экран не открывается, проверьте:
    
    - Правильно ли указан путь (существует ли такой файл в папке app).
        
    - Есть ли в _layout.tsx объявление Stack.Screen для этого экрана (если вы используете static navigation options).
        
    - Запущено ли приложение после установки Expo Router с правильной точкой входа (main: “expo-router/entry” в package.json).
        
    
- **Жёлтые предупреждения (YellowBox):** RN может выдавать предупреждения о несовместимых версиях, неподключенных listeners и т.п. Читайте эти сообщения – зачастую они подсказывают, что именно исправить. Например, предупреждение типа “Non-serializable values were found in the navigation state” может возникнуть, если вы пытаетесь передать в навигацию несериализуемый объект. Решение – передавать только простые данные (примитивы, вроде строк и чисел, например id).
    

  

Столкнувшись с ошибкой, не унывайте: внимательно читайте текст ошибки – он обычно указывает на строку и суть проблемы. Используйте React Developer Tools или логи (console.log) для отладки состояния приложения. Со временем вы научитесь быстро понимать типичные ошибки.

  

## **Домашнее задание**

  

Закрепите пройденный материал выполнением следующих заданий дома:

1. **Расширение функциональности приложения рецептов:** Добавьте в приложение ещё один экран списка, например, “Избранное” (app/favorites.tsx), где будут отображаться избранные рецепты. Пока можно заполнить его статическими данными (аналогично главному экрану). Добавьте на главном экране кнопку, которая будет перенаправлять на экран “Избранное”. Попробуйте поделиться логикой с главным экраном (можно вынести список рецептов в отдельный массив и импортировать в разные экраны).
    
2. **Стилизация и платформа:** Примените условную стилизацию с использованием Platform.OS. Например, сделайте шрифт заголовка рецепта (экран RecipeDetail) больше на iOS и меньшего размера на Android. Или покажите на экране профиля дополнительный текст только для Android-пользователей.
    
3. **Исследование документации:** Самостоятельно изучите документацию по компоненту ScrollView и найдите, как реализовать горизонтальную прокрутку. Попробуйте добавить горизонтальный ScrollView на каком-либо экране (например, галерею изображений на экране рецепта, с прокруткой по горизонтали). Это поможет вам лучше понять, как настраиваются компоненты прокрутки.
    

  

Выполнение этих заданий поможет углубить понимание React Native. На следующем занятии мы перейдём к новым темам, а также разберём ваши вопросы и результаты домашнего проекта.